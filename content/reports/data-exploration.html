<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.31">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Thomas Brochhagen">
<meta name="dcterms.date" content="2025-10-31">

<title>Colors and referent data</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="data-exploration_files/libs/clipboard/clipboard.min.js"></script>
<script src="data-exploration_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="data-exploration_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="data-exploration_files/libs/quarto-html/popper.min.js"></script>
<script src="data-exploration_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="data-exploration_files/libs/quarto-html/anchor.min.js"></script>
<link href="data-exploration_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="data-exploration_files/libs/quarto-html/quarto-syntax-highlighting-e1a5c8363afafaef2c763b6775fbf3ca.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="data-exploration_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="data-exploration_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="data-exploration_files/libs/bootstrap/bootstrap-81267100e462c21b3d6c0d5bf76a3417.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Colors and referent data</h1>
<p class="subtitle lead">A first look</p>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Thomas Brochhagen </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">October 31, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>This is a summary of my first closer look at the data to identify potential forks in the analysis and take some decisions in advance. Particularly prior to collecting the image data.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(dplyr)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="fu">setwd</span>(<span class="st">'~/color'</span>)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>df <span class="ot">&lt;-</span> readr<span class="sc">::</span><span class="fu">read_csv</span>(<span class="st">'data/colors and referents data.csv'</span>)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>dff <span class="ot">&lt;-</span> df <span class="sc">%&gt;%</span> <span class="fu">filter</span>(<span class="sc">!</span><span class="fu">is.na</span>(source))</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>df_colex <span class="ot">&lt;-</span> dff <span class="sc">%&gt;%</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(stringr<span class="sc">::</span><span class="fu">str_detect</span>(source, <span class="st">","</span>))</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>df_unraveled <span class="ot">&lt;-</span> dff <span class="sc">%&gt;%</span> tidyr<span class="sc">::</span><span class="fu">separate_rows</span>(source, <span class="at">sep =</span> <span class="st">","</span>) <span class="sc">%&gt;%</span> </span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="at">source =</span> stringr<span class="sc">::</span><span class="fu">str_trim</span>(source))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>There are 1758 total data points, with 578 rows that indicate a source referent for a given color word in a language. Out of the latter, there are 223 rows that have more than one source (e.g., <code>RAW, FRESH</code> for <em>green</em> instead of just <code>RAW</code> or just <code>FRESH</code>). Unravelling these ambiguous entries so that each possible source gets its own row gives a total of 958 data points with a potential source (but at most 578 will be the true source, the others are incidental colexifications or unclear sources).</p>
<p>In other words, 355 data points are straightforward to analyze in that they provide a one-to-one color-source mapping. The other 223 entries need to be dealt with, probably case by case since they are a mixed bag. More on this at the end of the document.</p>
</section>
<section id="sources" class="level2">
<h2 class="anchored" data-anchor-id="sources">Sources</h2>
<p>To get a better feeling for the data, I focused on the sources and their potential representation by images. I expect that this will be the main factor impacting the amount of data we ultimately have to analyze. Taking all potential sources as a starting point, we have 239 in total.</p>
<p>Here’s the top 20, with total count of occurence added:</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>df_unraveled <span class="sc">%&gt;%</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">group_by</span>(source) <span class="sc">%&gt;%</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">summarize</span>(<span class="at">n =</span> <span class="fu">n</span>()) <span class="sc">%&gt;%</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">arrange</span>(<span class="fu">desc</span>(n)) <span class="sc">%&gt;%</span> </span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">head</span>(<span class="at">n =</span> <span class="dv">20</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 20 × 2
   source        n
   &lt;chr&gt;     &lt;int&gt;
 1 DARK         73
 2 UNRIPE       37
 3 PALE         35
 4 LIGHT        32
 5 RAW          29
 6 RIPE         25
 7 TAN          21
 8 BLOOD        19
 9 SHINE        19
10 CLEAR        16
11 DIM          16
12 DIRTY        16
13 EARTH        16
14 ASH          15
15 GRAY HAIR    15
16 DUST         14
17 PAINT        13
18 BILE         12
19 FRESH        12
20 BLOND        11</code></pre>
</div>
</div>
<p>This is to say that there’s some repetition but also a long tail of sources that appear only once.</p>
<p>Here’s the tail:</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>df_unraveled <span class="sc">%&gt;%</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">group_by</span>(source) <span class="sc">%&gt;%</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">summarize</span>(<span class="at">n =</span> <span class="fu">n</span>()) <span class="sc">%&gt;%</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">arrange</span>(<span class="fu">desc</span>(n)) <span class="sc">%&gt;%</span> </span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">tail</span>(<span class="at">n =</span> <span class="dv">20</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 20 × 2
   source                       n
   &lt;chr&gt;                    &lt;int&gt;
 1 SPRING                       1
 2 SPROUT                       1
 3 STRAW                        1
 4 SULPHUR-CRESTED COCKATOO     1
 5 SURFACE                      1
 6 TARWEED                      1
 7 TENDER                       1
 8 TREE                         1
 9 TUNDRA                       1
10 UHIUHI                       1
11 URINE                        1
12 VENUS                        1
13 VIOLA                        1
14 VITILIGO                     1
15 WEASEL                       1
16 WESTERN BLUEBERRY            1
17 WHITE                        1
18 WIPE                         1
19 WORLD                        1
20 YELLOW-BELLIED SAPSUCKER     1</code></pre>
</div>
</div>
<p>Inspecting 239 cases is not that much work. I am attaching the list to an email to you for convenience. What follows are my comments based on this inspection.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="fu">writeLines</span>(<span class="fu">unique</span>(df_unraveled<span class="sc">$</span>source), <span class="st">'data/unique_sources.txt'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="comments" class="level2">
<h2 class="anchored" data-anchor-id="comments">Comments</h2>
<p>In trying to make sense of the data, I tried to roughly categorize the sources. Here’s what I got, in very rough strokes:</p>
<ul>
<li><strong>Category 1</strong>: Depictable by a concrete object without an issue
<ul>
<li>Examples: NILGIRI BARBERRY, GREAT CUCKOO DOVE, SCARLET FLYCATCHER, WESTERN BLUEBERRY</li>
</ul></li>
<li><strong>Category 2</strong>: Depictable indirectly through many instances since it may vary in color/shape from instance to instance but not very context/culture/environment dependent if we take a big enough sample
<ul>
<li>Examples: NIGHT, SKY, SMOKE, BRUISE</li>
</ul></li>
<li><strong>Category 3</strong>: Not depictable because it is abstract and/or the color is relative to the object it modifies
<ul>
<li>Examples: BEAUTY, PALE, JAUNDICE, FAIR, CLEAN, SHINE</li>
</ul></li>
<li><strong>Category 4</strong>: Possibly depictable indirectly through many instances but some pre-selection may be required (compared to Category 2)
<ul>
<li>Examples: RAW/FRESH/RIPE (as pictures of raw fruit but not other raw objects, like meat), DARK, POWDER</li>
</ul></li>
<li><strong>Category 5</strong>: Depictable but local context may matter for color
<ul>
<li>Examples: ROSE, CLAY, MUD</li>
</ul></li>
</ul>
<hr>
<p>My comments on this, in no particular order:</p>
<ol type="1">
<li><p>Categories 1,2,3 are relatively straightforward. For Category 1 and Category 2 I would just try to get a large enough sample, process those and let the results be what they will be. I see no way to retain data from Category 3 (e.g., <code>BEAUTY</code>).</p></li>
<li><p>On the topic of membership to Category 3: As a community, we really should push for English not be used as a meta-language. Not being able to tell properties from referents (e.g., <code>DARK</code> instead of, say, <code>OSCURO</code> vs.&nbsp;<code>OSCURIDAD</code> using Spanish) makes me doubt if some sources that look adjectival could be treated more like nouns for the present purpose. If <code>DARK</code> is about <em>the dark</em>/<em>darkness</em> then we can treat it like <code>NIGHT</code> and just look at many images that depict darkness. If it’s a dark object then it’s Category 3 for me (like <code>BEAUTIFUL</code>) because that largely depends on a comparison class (<em>dark for a X</em>).</p></li>
<li><p>This is a good transition into the next category. Category 4 is tricky because I think that’s where it’s easiest to deceive ourselves by selecting based on the color term (e.g., selecting green fruit for <code>RAW</code> because the basic color term is often <em>green</em>). A solution would be to have the images collected by someone who doesn’t know the color term; or even better, has no knowledge of the project at all. This is risky though since we may be burrying the true result in the noise we get by selecting without full information. One may argue that we “know” that the referents should be <em>green</em> because we know the SOURCE-&gt;COLOR path that we’re trying to describe. But that sounds pretty biased in favour of ourselves and what we think we may find to me.</p></li>
<li><p>Category 5 is like 4 but a little less controversial: where we suspect that context of where the language is spoken matters, we select for images of sources that -as much as possible- are close to those found in the environment where the language is spoken. This is what we have discussed the most but, on a skim, there are not that many cases of these compared to Category 3 or the property/referent issue mentioned above.</p></li>
<li><p>Multiple sources for a single color term. Matthias raised this issue already: there are entries with multiple potential sources like <code>GOLD, CASSUMUNAR GINGER</code> for <em>yellow</em>. If we do not have a way to determine what the source is, which I imagine we will not have, I see three options:</p></li>
</ol>
<ul>
<li>Exclude these data points since it is unclear what the source is;</li>
<li>Retain all sources that can be depicted and run the analysis once per potential source for each color term. So we end up with a lot of analyses. For instance, one using <code>GOLD</code> for <em>yellow</em> and the other using <code>CASSUMUNAR GINGER</code> for <em>yellow</em>, for the example above. One of these is “the true analysis” where each correct source is analyzed. Maybe this shouldn’t be done as the main analysis but it could be a robustness check with this “fuller” set of data.</li>
<li>Retain all sources that can be depicted but, after pruning the data for only sources that can be depicted, exclude those data points that still have multiple potential sources. This allows us to retain some data points if, by chance, after prunning for depictability, they now only have one source left. But this also introduces a bias toward an analysis that prioritizes potential sources that are depictable. There are some theoretical reasons why this may not be too bad of a bias –a lot of researchers have argued that the most common extension is from concrete to abstract, and this probably correlates with depictable vs.&nbsp;non-depictable– but it’s something to keep in mind.</li>
</ul>
<ol start="6" type="1">
<li>Pseudo-synonymy: one-to-many color-source mappings. The assumption of using only basic color terms (which I still endorse for lack of a better alternative) shows its limits very fast in some languages. For Basque, for instance, there are a lot of words associated to <em>gray</em> but different sources (<code>MUD</code> vs.&nbsp;<code>DIRTY</code>, vs.&nbsp;<code>BRUISE</code>) and word forms. I imagine these different words do not really denote the same color but that they are all being conflated under the label, <em>gray</em>. I don’t know what to do with these. There are 97 cases (out of 579) in which for a given glottocode and a given basic color term there is more than one entry for its potential source.</li>
</ol>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>dff <span class="sc">%&gt;%</span> </span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">select</span>(glottocode, standardized_reference_color, source) <span class="sc">%&gt;%</span> </span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">unique</span>() <span class="sc">%&gt;%</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">group_by</span>(glottocode, standardized_reference_color) <span class="sc">%&gt;%</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">summarize</span>(<span class="at">n =</span> <span class="fu">n</span>()) <span class="sc">%&gt;%</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">arrange</span>(<span class="fu">desc</span>(n)) <span class="sc">%&gt;%</span> </span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(n <span class="sc">&gt;</span> <span class="dv">1</span>) <span class="sc">%&gt;%</span> </span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">nrow</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<ol start="7" type="1">
<li>Relatedly, there’s also the opposite case where different basic color terms match to the same source concept: Again, for Basque, there’s <em>red</em> (gorri) and <em>purple</em> (gorrindol) that both have <code>RED WINE, RUDDY</code> as source. That makes sense because they partially colexify, with purple being (<code>RED</code>+indol). So the data codification here is working as intended. But I’m pointing this out because at some point we worried that maybe we were testing something obvious that follows from the way we’re preparing the data; and this is a clear example of how messy things get: these many-to-one mappings necessarily go against the hypothesis that focal colors of source referents map to focal color spaces –since the same referent can’t both the prototypically <code>RED</code> and prototypically <code>PURPLE</code>. Two options I see:</li>
</ol>
<ul>
<li>We acknowledge that this works against our hypothesis and just live with it; or</li>
<li>We elaborate exclusion criteria that deal with (some of) these. Since the data is small, I think we can do that. Taking Basque as an example that I think can/should be excluded, “gorrindol” is the more complex form (<code>RED</code>+suffix). I think it’s sensible in this case to exclude the morphologically more complex form when two colors partially colexify. The argument is that we’re studying <code>SOURCE</code>-&gt;<code>COLOR</code> relationships and in this case the likely chain is <code>RED WINE, RUDDY</code>-&gt;<code>RED</code>-&gt;<code>PURPLE</code>. So we are not interested in “gorrindol”/<code>PURPLE</code> since the chain is longer and we exclude it. The counterargument is obviously that <code>RED</code>-&gt;<code>PURPLE</code> is still a <code>SOURCE</code>-&gt;<code>COLOR</code> relationship so it ought to be included. There are also cases where the source is another color serves as the source (the source for purple in Bororoan is <code>RED</code>) but I see no surface similarity between the forms. In that case, I think we just need to live with it. There’s a total of 87 cases where for a given glottocode the same source is associated with more than one basic color term.</li>
</ul>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>dff <span class="sc">%&gt;%</span> </span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">select</span>(glottocode, standardized_reference_color, source) <span class="sc">%&gt;%</span> </span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">unique</span>() <span class="sc">%&gt;%</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">group_by</span>(glottocode, source) <span class="sc">%&gt;%</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">summarize</span>(<span class="at">n =</span> <span class="fu">n</span>()) <span class="sc">%&gt;%</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">arrange</span>(<span class="fu">desc</span>(n)) <span class="sc">%&gt;%</span> </span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(n <span class="sc">&gt;</span> <span class="dv">1</span>) <span class="sc">%&gt;%</span> </span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">nrow</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<hr>
</section>
<section id="decisions" class="level2">
<h2 class="anchored" data-anchor-id="decisions">Decisions</h2>
<ul>
<li><p>Do we treat sources that would otherwise be discarded because they are properties relative to a referent (<code>DARK</code> or <code>LIGHT</code>) as “nouns” so that we can depict them (“darkness” (oscuridad; Dunkelheit) and “light” (luz; Licht)? I would say yes. That saves some of the data that would otherwise be part of Category 3 but not all of it (<code>BEAUTY</code>).</p></li>
<li><p>How to select images for Category 4 in the most unbiased way possible without adding noise that will work against the analysis later on (Comment 4). Not sure about this one. The cleanest solution I have is to categorize most of them as Category 3, since they are relative to the referent they modify (e.g., <code>RAW</code>) and to move the remainder up to Category 5 (e.g., <code>POWDER</code>). In other words, maybe Category 4 is not a helpful category after all and it just comes from my attempt to retain some sources where I can imagine the color to be appropriately captures (<code>RAW</code> as green).</p></li>
<li><p>What do do with cases of multiple sources (Comment 5). I would do the third option I mention for the main analysis; and the second one as a robustness/sanity check. But I’m not too sure so very open to suggestions.</p></li>
<li><p>What do do with Pseudo-Synonymy (Comment 6). Not sure here.</p></li>
<li><p>What to do with many-colors-to-one-source mappins (Comment 7). I think we just need to live with it. It is concerning that this is about 1/5 of the data (prior to pruning for sources that can be depicted) but I see no way around it.</p></li>
</ul>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>